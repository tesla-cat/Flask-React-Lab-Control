function [plgs, halfTotalWidth] = generateSingleJunction(varargin)

p = inputParser;

p.addParamValue('narrowWidth',        10.0);
p.addParamValue('narrowLength',         80);

p.addParamValue('fingerWidth',          0.400);
p.addParamValue('mushroomExtraWidth',   0.200);
p.addParamValue('bridgeExtraWidth',     0.200);

p.addParamValue('bridgeLength',         0.460);

p.addParamValue('needlesLength',          4.0); 
p.addParamValue('funnelRelativeLength',   2.0);

p.addParamValue('bridgeDataType',0);
p.addParamValue('fineDataType',0);

p.KeepUnmatched = true;

p.parse(varargin{:});
expandStructure(p.Results);

exl = narrowLength;
slw = narrowWidth;

brl = bridgeLength;
ndl = needlesLength;
fnl = funnelRelativeLength * slw;

jfw = fingerWidth;
msw = jfw + mushroomExtraWidth;
brw = msw + bridgeExtraWidth;

plgs = [ ...
    shSquare( trTranslate(-brl/2-ndl-fnl, 0)*trScale(exl, slw)*trTranslate(-0.5,0), ...   
       'layer', LYR_QUBIT_FINE, 'dataType', fineDataType) ...
    ...   
    shFunnel( trTranslate(-brl/2-ndl, 0)*trRotate(90), ...
       'startWidth', jfw, 'endWidth', slw, 'funnelLength', fnl, 'layer', LYR_QUBIT_FINE, 'dataType', fineDataType) ...
    ...   
    shSquare( trTranslate(-brl/2, 0)*trScale(ndl, jfw)*trTranslate(-0.5,0), ...   
       'layer', LYR_QUBIT_FINE, 'dataType', fineDataType) ...
    ...   
    shSquare( trScale(brl, brw), 'layer', LYR_QUBIT_FINE_BRIDGE, 'dataType', bridgeDataType) ...
    ...   
    shSquare( trTranslate(brl/2, 0)*trScale(ndl, msw)*trTranslate(+0.5,0), ...   
       'layer', LYR_QUBIT_FINE, 'dataType', fineDataType) ...
    ...   
    shFunnel( trTranslate(brl/2+ndl, 0)*trRotate(-90), ...
       'startWidth', msw, 'endWidth', slw, 'funnelLength', fnl, 'layer', LYR_QUBIT_FINE, 'dataType', fineDataType) ...
    ...
    shSquare( trTranslate(brl/2+ndl+fnl, 0)*trScale(exl, slw)*trTranslate(+0.5,0), ...   
       'layer', LYR_QUBIT_FINE, 'dataType', fineDataType) ];
        
if nargout == 2
    halfTotalWidth = brl/2+fnl+ndl+exl;
end

